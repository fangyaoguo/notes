# 离散化
将一个大数组的需要用到的数据放在小数组中，小数组去重排序，称为离散化数组
![[Pasted image 20240220202849.png]]
此题就是数组非常大，所以把用到的映射出来。
code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 9;
long long a[N];
vector<int> X;
int getidx(int x)
{
	return lower_bound(X.begin(),X.end(), x) - X.begin() + 1;
}
struct Q
{
	int a, b;
}add[N] , que[N];

void solve()
{	
	int n, q; cin >> n >> q;
	for(int i = 1; i <= n; i++)
	{
		int a,b; cin >> a >> b;
		X.push_back(a);
		add[i] = {a,b};
	}
	for(int i = 1; i <= q; i++)
	{
		int a,b; cin >> a >> b;
		X.push_back(a) , X.push_back(b);
		que[i] = {a,b};
	}
	sort(X.begin(),X.end());
	X.erase(unique(X.begin(),X.end()),X.end());
	for(int i = 1; i <= n; i++)
	{
		int x = getidx(add[i].a);
		long long val = add[i].b;
		a[x] += val;
	}
	for(int i = 1; i <= X.size(); i++)a[i] += a[i - 1];
	for(int i = 1; i <= q; i++)
	{
		int l = getidx(que[i].a);
		int r = getidx(que[i].b);
		cout<< a[r] - a[l - 1] << '\n';
	}
	
}
int main()
{
	ios::sync_with_stdio(0) ,cin.tie(0) , cout.tie(0);
	solve(); 
}

```
这个题目将长数组映射到a中用X记录用到的下标并将其转化成离散数组的下标
# 树状数组（不能用0做下标）
维护区间和 （单点修改，区间修改，区间查询）